<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Road of web</title>
  <subtitle>极客笔记</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ukhack.github.io/"/>
  <updated>2017-07-23T17:44:08.965Z</updated>
  <id>https://ukhack.github.io/</id>
  
  <author>
    <name>Zhang rui</name>
    <email>hack_uk@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://ukhack.github.io/%E5%AF%B9JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%BB%A5%E5%8F%8A%E9%A1%B9%E7%9B%AE%E6%AD%A3%E8%A7%84%E5%8C%96%E7%9A%84%E7%90%86%E8%A7%A3.html"/>
    <id>https://ukhack.github.io/对JS面向对象以及项目正规化的理解.html</id>
    <published>2017-07-23T17:44:08.964Z</published>
    <updated>2017-07-23T17:44:08.965Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript OOP的理解（一）</title>
    <link href="https://ukhack.github.io/JavaScript%20OOP%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89.html"/>
    <id>https://ukhack.github.io/JavaScript OOP的理解（一）.html</id>
    <published>2016-12-15T16:00:00.000Z</published>
    <updated>2017-07-24T03:55:33.528Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-OOP的理解（一）"><a href="#JavaScript-OOP的理解（一）" class="headerlink" title="JavaScript OOP的理解（一）"></a>JavaScript OOP的理解（一）</h1><h5 id="2016-12-16-星期六"><a href="#2016-12-16-星期六" class="headerlink" title="2016-12-16 星期六"></a>2016-12-16 星期六</h5><p>这篇文章旨在记录我个人在日常编码中对 JavaScript 面向对象编程的一些理解，由于阅历原因，可能有些片面和不足，欢迎指出。</p>
<h2 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h2><p>OOP ：面向对象编程。如果接触过 JAVA 或者 C++ 那么应该很清楚这个概念，OOP有三大特征即：封装、继承和多态。</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装是指将数据与操作包装成为一个单独的实体，数据尽可能的被隐藏在内部，而只保留一些对外的接口使之与外部联系。</p>
<p>使用好封装可以带来以下几点好处：</p>
<ol>
<li><p>好的封装可以减少模块间的耦合，提高内聚性</p>
</li>
<li><p>可以隐藏不想被外部知道的细节，提升安全性</p>
</li>
<li><p>可以更精准的控制内部的成员变量</p>
</li>
</ol>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>OOP 的主要功能之一就是继承。我们知道，在实际项目中，代码复用是非常重要的。我们不必要为了修改一点点不同的功能而又去重新写一模一样的代码。</p>
<p>继承是一种能力，我们可以从现有的类中派生出一个新类。被基础的类叫做“基类”或者“父类”，派生出的类叫做“派生类”或者“子类”。派生类可以从基类继承方法和变量，同时可以加入新的方法，这将不会影响父类的现有代码，同时减少了很多的重复代码。</p>
<p>在 JAVA 项目中我们可以看到很多这样的实例，如 java.lang 包中，很多的类都被继承。或者是当前很热的 ORM 框架 Mybatis 的 resultMap 也是支持继承的。</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>在现实中，多态的例子其实很多：比如说按下F5按键，在浏览器页面和桌面是刷新，在word中是查找替换，而在PPT中又是播放。同样一个按钮，不同的场景功能就不同。</p>
<p>那么多态的含义就好理解了：对于不同类的对象，允许他们对同一个消息响应。就是说同一个消息可以根据不同的对象来采用不同的方式。</p>
<p>实现多态必须满足：</p>
<ol>
<li>完成继承</li>
<li>完成重载</li>
<li>父类引用指向子类</li>
</ol>
<p>以上是面向对象的三个基本特征，如果能够符合，那么就是面向对象。那么我们来看看 JS 如何做到面向对象。</p>
<h2 id="JavaScript-OOP"><a href="#JavaScript-OOP" class="headerlink" title="JavaScript OOP"></a>JavaScript OOP</h2><p>上面讲了 OOP 的基本的特征，但是有一个问题我们大家心里面都是有数的。那就是：JavaScript 压根没有 class（ES2015以及更早），这就导致 JS 的编写很尴尬。<br>在我的工作过程中，我实际编写了很多的 JS 模块，纵观这些代码也是我进步的一个过程。同时我也在维护前辈们留下的代码。最为头疼的就是有时候打开一个 JS 文件，四千多行，没有注释，满屏幕都是 function xx(){…} ，项目赶得紧又没有多余时间去重写这些文件，想死的心都有了。<br>所以我宁可去维护后端也不想去维护前端，我也很无奈~究其原因就是项目组来来去去的人员变动的大，水平也参差不齐。如果他们能掌握 OOP ，那么写出来的代码也更易于阅读，对我们这些晚辈也更友好。<br>回到正题。<br>在传统的面向对象语言中，我们可以说，我为 Car 类创建了一个对象叫 Audi 。而由于JS缺少class特性，并且JS完全是基于对象的，依靠的是一套原型系统（prototype）。在 JS 中，我们可以说，我把 Car 对象扩展成了 Audi新对象。</p>
<table>
<thead>
<tr>
<th>示例</th>
<th>概念</th>
</tr>
</thead>
<tbody>
<tr>
<td>奥迪a6是小轿车（小轿车是对象）</td>
<td>对象</td>
</tr>
<tr>
<td>奥迪a6 价格400K，排量1.8T</td>
<td>属性</td>
</tr>
<tr>
<td>奥迪a6 起步，加油，刹车，换挡</td>
<td>方法</td>
</tr>
<tr>
<td>奥迪是小轿车类的一个实例</td>
<td>传统的OOP</td>
</tr>
<tr>
<td>奥迪是小轿车对象扩展出来的新对象</td>
<td>基于原型的OOP</td>
</tr>
<tr>
<td>奥迪 a6 中包含了坐垫，内饰等数据，以及更换坐垫，更换内饰等方法</td>
<td>封装</td>
</tr>
<tr>
<td>奥迪的起步，刹车，换挡都是扩展自小轿车对象的新对象</td>
<td>继承</td>
</tr>
<tr>
<td>我们可以调用奥迪的驾驶，宝马的驾驶，奔驰的驾驶，他们风格不同导致结果不同</td>
<td>重载，多态</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JavaScript-OOP的理解（一）&quot;&gt;&lt;a href=&quot;#JavaScript-OOP的理解（一）&quot; class=&quot;headerlink&quot; title=&quot;JavaScript OOP的理解（一）&quot;&gt;&lt;/a&gt;JavaScript OOP的理解（一）&lt;/h1&gt;&lt;
    
    </summary>
    
    
      <category term="实习" scheme="https://ukhack.github.io/tags/%E5%AE%9E%E4%B9%A0/"/>
    
      <category term="javascript" scheme="https://ukhack.github.io/tags/javascript/"/>
    
      <category term="OOP" scheme="https://ukhack.github.io/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>项目中jquery遇到问题的反思和总结</title>
    <link href="https://ukhack.github.io/%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8Jquery%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98%E7%9A%84%E5%8F%8D%E6%80%9D%E4%B8%8E%E6%80%BB%E7%BB%93.html"/>
    <id>https://ukhack.github.io/项目使用Jquery遇到问题的反思与总结.html</id>
    <published>2016-12-05T16:00:00.000Z</published>
    <updated>2017-07-24T02:11:01.930Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Jquery遇到问题的反思和总结"><a href="#Jquery遇到问题的反思和总结" class="headerlink" title="Jquery遇到问题的反思和总结"></a>Jquery遇到问题的反思和总结</h1><h5 id="2016-12-6-星期二"><a href="#2016-12-6-星期二" class="headerlink" title="2016-12-6 星期二"></a>2016-12-6 星期二</h5><p>这篇文章不是介绍如何使用jquery，而是旨在总结我在擎天实习期间，在项目上使用 jquery 时遇到的问题的一个反思和总结。由于项目必须兼容IE8，所以下面的内容都是基于 Jquery1.8 以及以下的版本。</p>
<h2 id="问题1：绑定事件"><a href="#问题1：绑定事件" class="headerlink" title="问题1：绑定事件"></a>问题1：绑定事件</h2><p>我们知道，Jquery 中常用的给指定元素绑定监听事件方法之一是 bind 方法。例如:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'#p1'</span>).bind(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'hello p1'</span>)&#125;);</div></pre></td></tr></table></figure>
<p>显而易见的，在控制台会打印出 “hello p1” 这段字符。<br>但是 Jquery 一大功能就是对 ajax 取到的数据进行解析，然后修改 DOM 节点。很多的新的节点被动态的附加到 DOM 树上，这时候我们写好的 bind 方法对这些节点将会失效。<br>查文档得知 Jquery 还有一个方法 ：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.live(type, [data], fn)</div></pre></td></tr></table></figure>
<p>这个方法对 append,after 等等都有效。为什么这个方法对后来附加的方法有效？<br>这个原理其实可以追溯到我们刚接触到 js 时会遇到的一个问题，那就是：事件冒泡。也就是说，我们其实是将方法放在了document 这个节点，在触发点击事件时进行冒泡，最后对对象进行匹配。这又称作“事件委托”。<br>激动的改成了 live() 以后，没想到程序居然跑不起来了，这是为什么？<br>在这个文件中，我为了优化 jq 的效率用到了很多类似：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ele=$(<span class="string">'#dataForm .reportData'</span>);</div><div class="line">ele.find(<span class="string">' .dataTitle'</span>).bind....</div><div class="line">ele.find(<span class="string">' .dataDetail'</span>).bind...</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>充分利用 jq 的缓存可以优化我们的运行速度。但是恰巧，在 api 文档中我发现了如下的一个问题：</p>
<p><img src="..\uploads\jquery1.png" alt="jquery1"></p>
<p>.live() 方法居然是不支持 find 遍历的。其实 .live() 在 jq1.7 这个版本已经不再推荐使用了，取而代之的是 on 方法，live 方法确实也存在着很多问题。<br>换成了 .on() 以后，问题得到了解决。</p>
<h2 id="问题2：待补充"><a href="#问题2：待补充" class="headerlink" title="问题2：待补充"></a>问题2：待补充</h2><h4 id="版权"><a href="#版权" class="headerlink" title="版权"></a>版权</h4><p>author : <code>zhangrui</code><br>授权     ：自由转载-非商用</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Jquery遇到问题的反思和总结&quot;&gt;&lt;a href=&quot;#Jquery遇到问题的反思和总结&quot; class=&quot;headerlink&quot; title=&quot;Jquery遇到问题的反思和总结&quot;&gt;&lt;/a&gt;Jquery遇到问题的反思和总结&lt;/h1&gt;&lt;h5 id=&quot;2016-12-6
    
    </summary>
    
    
      <category term="实习" scheme="https://ukhack.github.io/tags/%E5%AE%9E%E4%B9%A0/"/>
    
      <category term="生活" scheme="https://ukhack.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="javascript" scheme="https://ukhack.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js 手札（一）</title>
    <link href="https://ukhack.github.io/Vue-1.html"/>
    <id>https://ukhack.github.io/Vue-1.html</id>
    <published>2016-11-10T16:00:00.000Z</published>
    <updated>2016-11-16T04:05:24.752Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="编程学习" scheme="https://ukhack.github.io/tags/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Vue" scheme="https://ukhack.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>REST成熟度的思考</title>
    <link href="https://ukhack.github.io/REST%E6%88%90%E7%86%9F%E5%BA%A6%E7%9A%84%E6%80%9D%E8%80%83.html"/>
    <id>https://ukhack.github.io/REST成熟度的思考.html</id>
    <published>2016-10-17T16:00:00.000Z</published>
    <updated>2017-07-11T10:16:38.726Z</updated>
    
    <content type="html"><![CDATA[<h1 id="REST成熟度"><a href="#REST成熟度" class="headerlink" title="REST成熟度"></a>REST成熟度</h1><h5 id="2016-10-18-周二"><a href="#2016-10-18-周二" class="headerlink" title="2016-10-18 周二"></a>2016-10-18 周二</h5><p>上篇文章我分析了<a href="https://ukhack.github.io/2016-10-17-RESTful-1.html"> REST 接口的命名规范</a>，大概是从十个方面分析了这个技术。这篇文章探讨在 REST 发展过程中形成的几个成熟度模型。</p>
<blockquote>
<p>Recently I’ve been reading drafts of Rest In Practice: a book that a couple of my colleagues have been working on. Their aim is to explain how to use Restful web services to handle many of the integration problems that enterprises face. At the heart of the book is the notion that the web is an existence proof of a massively scalable distributed system that works really well, and we can take ideas from that to build integrated systems more easily.</p>
<p><a href="https://martinfowler.com/articles/richardsonMaturityModel.html" target="_blank" rel="external">Martin Fowler</a></p>
</blockquote>
<p>最近，我拜读了《 REST 实战》这本书的草案。我的很多同事参与了此书的编写。他们旨在研究如何在 web 服务中使用 RESTful 来解决很多企业面临的集成问题。这本书的核心观点就是： web 的存在证明了大规模可扩展的分布式系统，我们可以借鉴书里面的思想来让我们的更简单的搭建集成系统。（原谅我捉鸡的翻译）</p>
<p>首先先祭出这张图片：</p>
<p><img src="..\uploads\rest1018.png" alt="rest1018"></p>
<p>从下往上看是四级。</p>
<h2 id="Level-0"><a href="#Level-0" class="headerlink" title="Level 0"></a>Level 0</h2><p>为什么叫 level 0 呢？那是因为这个级别在当前阶段可以说是不属于 REST 范畴的，只是用以说明 REST 发展的历史。</p>
<p>在这个级别我们使用 XML (也有 JSON 、YAML 或者其他)，只有POX被传输，基本就是 RPC 的风格。如 SAOP也是相似的，只是格式不同而已。所以说，Level 0 是不应该属于REST的。</p>
<h2 id="Level-1"><a href="#Level-1" class="headerlink" title="Level 1"></a>Level 1</h2><p>在该成熟度模型中，我们可以看到。REST 入门级别是资源级别：就是将所有的请求抽象为对资源的操作。例如下面的一个例子</p>
<p><img src="..\uploads\rest10182.png" alt="rest10182"></p>
<p>这个接口是微信公众号的数据分析接口，对用户数据进行了资源化。我们不难看出，虽然依然是 POX 但是每一个资源都拥有其独立的 URL 地址。这就是 Level 1 的要求，每一个资源对应独立的 URL 地址。</p>
<p>我们可以看到，微信公众号这两个接口的命名其实是不满足我上一篇文章所说的， url 应该只包含名词，而不是动词。所以我们接下来继续分析 Level 2 。</p>
<h2 id="Level-2"><a href="#Level-2" class="headerlink" title="Level 2"></a>Level 2</h2><p>level 2 级别引入了 http 动词的概念，即：url中应该存在的是资源的名词形式，而不应该存在形如 get 、 set 这样的动词，我们应该在请求中用 http 动词替代 url 中的动词。</p>
<p>常用的 HTTP 动词如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">GET (SELECT)    : 从服务器获取资源。</div><div class="line">POST (CREATE)   : 在服务器新建一个资源</div><div class="line">PUT (UPDATE)    : 在服务器更新一个资源（修改后的完整资源）</div><div class="line">PATCH (UPDATE)  : 在服务器更新一个资源（修改的某一项属性）</div><div class="line">DELETE (DELETE) : 在服务器删除资源</div></pre></td></tr></table></figure>
<p>如：</p>
<p><img src="..\uploads\rest10183.png" alt="rest10183"></p>
<p>这是微信公众平台的长链接获取短链接的接口，这个接口就用了名词的 shorturl 和 http 动词 POST 让开发者一目了然。而这里为什么使用 POST 而不是 GET 呢？</p>
<p>可以这么看，获取短链接其实也是创建了一个短链接的资源，这个资源原本是不存在的。不必要过于墨守成规。我翻阅了一遍微信公众平台的 api 遗憾的是，可能是历史的原因，微信公众平台的很多接口其实只能算是一级成熟度的 REST。</p>
<h2 id="Level-3"><a href="#Level-3" class="headerlink" title="Level 3"></a>Level 3</h2><p>我们再次祭出这张图片：<br><img src="..\uploads\rest1018.png" alt="rest1018"></p>
<p>从字面上理解 level 3 是超媒体控制。这个像是机翻的中文名看起来很是令人困惑。什么叫做超媒体控制？</p>
<p>别急，让我来举一个简单的例子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -X curl https://*.wilddogio.com/books.json</div></pre></td></tr></table></figure>
<p>响应：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  "book1":&#123;</div><div class="line">    "name": "书1",</div><div class="line">    "next": "*.wilddogio.com/books/book2.json",</div><div class="line">    "self": "*.wilddogio.com/books/book1.json"</div><div class="line">  &#125;,</div><div class="line">  "book2":&#123;</div><div class="line">    "name": "书2",</div><div class="line">    "next": "*.wilddogio.com/books/book3.json",</div><div class="line">    "self": "*.wilddogio.com/books/book2.json"</div><div class="line">  &#125;,</div><div class="line">  "book3":&#123;</div><div class="line">    "name": "书3",</div><div class="line">    "self": "*.wilddogio.com/books/book3.json"</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们看其中一个：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">"book2":&#123;</div><div class="line">  "name": "书2",</div><div class="line">  "next": "walletdemo.wilddogio.com/books/book3.json",</div><div class="line">  "self": "walletdemo.wilddogio.com/books/book2.json"</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>Level 3 对REST请求已经没有要求，而要求响应做一定的更改。它要求响应体具有一定的自描述性：即开发者阅读了这个响应以后就算不借助api文档也能明白下一步该做什么。</p>
<p>book2资源的响应描述了自己的url地址，以及它的下一个地址。所有的资源通过url串联在一起。这就是 Level 3似乎并没有想像中的那么难吧？不过目前 Level 3 正在制定中，并没有一个成型的规则去约束，所以我们只要满足自描述这个要求即可，而如何描述，描述成什么样子这就需要等待新的规则制定出来。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>REST 就分析到这里啦，希望看到这篇文章的有心人可以将这篇理论带到实战中去。我是 zhang rui ，乐于分享不一样的知识。</p>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><blockquote>
<p><a href="https://martinfowler.com/articles/richardsonMaturityModel.html" target="_blank" rel="external">Richardson成熟度模型</a><br><a href="http://www.cnblogs.com/moonz-wu/p/4211626.html" target="_blank" rel="external">好API的设计原则</a><br><a href="https://ukhack.github.io/2016-10-17-RESTful-1.html">RESTful 学习手记（一）</a></p>
</blockquote>
<h4 id="版权"><a href="#版权" class="headerlink" title="版权"></a>版权</h4><p>author : <code>zhangrui</code><br>授权     ：自由转载-非商用</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;REST成熟度&quot;&gt;&lt;a href=&quot;#REST成熟度&quot; class=&quot;headerlink&quot; title=&quot;REST成熟度&quot;&gt;&lt;/a&gt;REST成熟度&lt;/h1&gt;&lt;h5 id=&quot;2016-10-18-周二&quot;&gt;&lt;a href=&quot;#2016-10-18-周二&quot; class
    
    </summary>
    
    
      <category term="RESTful" scheme="https://ukhack.github.io/tags/RESTful/"/>
    
      <category term="编程学习" scheme="https://ukhack.github.io/tags/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>RESTful 手札（一）</title>
    <link href="https://ukhack.github.io/2016-10-17-RESTful-1.html"/>
    <id>https://ukhack.github.io/2016-10-17-RESTful-1.html</id>
    <published>2016-10-16T16:00:00.000Z</published>
    <updated>2016-10-18T11:53:15.428Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RESTful-学习手记（一）"><a href="#RESTful-学习手记（一）" class="headerlink" title="RESTful 学习手记（一）"></a>RESTful 学习手记（一）</h1><h5 id="2016-10-17-周一"><a href="#2016-10-17-周一" class="headerlink" title="2016-10-17 周一"></a>2016-10-17 周一</h5><p>在如今前后端分离的大潮流下，诞生了各种 API 框架。其中最火发展最成熟的 RESTful API 设计思想也催生了很多新潮的 API 框架。</p>
<blockquote>
<p>REST APIs are a very common topic nowaday; they are part of almost every web application. A simple, consistent and pragmatic interface is a mandatory thing; it will be <em>much</em> easier for others to use your API. Even if these practices may look common to your eye, I often see people that don’t really respect them. That’s why I decided to write a post about it.</p>
<p><a href="https://bourgeois.me/rest/" target="_blank" rel="external">bourgeois</a></p>
</blockquote>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p><a href="http://baike.baidu.com/view/9472.htm" target="_blank" rel="external">HTTP</a>/<a href="http://baike.baidu.com/view/14121.htm" target="_blank" rel="external">HTTPS</a></p>
<h2 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h2><p>提倡专用二级域名如下：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">https://api.domains.com</span></div></pre></td></tr></table></figure>
<p>如果项目较小，也可以考虑如下方式</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">https://www.domains.com/api/something</span></div></pre></td></tr></table></figure>
<p>这两种方式都是合理的，可在实际项目中酌情选择</p>
<h2 id="API-版本"><a href="#API-版本" class="headerlink" title="API 版本"></a>API 版本</h2><p>api 版本号应该显式的约定在在 url 中</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">https://api.domains.com/v1</div><div class="line">https://domains.com/api/v1/</div></pre></td></tr></table></figure>
<p>Github 的 api 隐藏在接收到的 http <code>head</code> 信息中。</p>
<p>使用版本号可以让你在更新 api 时避免破坏旧版本的 api</p>
<h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><p>Endpoint 应该是复数名词而不是动词。在 RESTful 中，一个网址即对应一个资源。</p>
<p>形如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">https://api.domains.com/v1/soaps</div><div class="line">https://api.domains.com/v1/gays</div><div class="line">https://api.domains.com/v1/programmers</div></pre></td></tr></table></figure>
<p>是合理的。</p>
<p>而形如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">https://api.domains.com/v1/pickSoaps</div><div class="line">https://api.domains.com/v1/becomeGay</div><div class="line">https://api.domains.com/v1/getProgrammers</div></pre></td></tr></table></figure>
<p>这种传统的 get\set 或者包含其他动词的 <code>Endpoint</code> 应该避免。</p>
<p>那么我们该怎么实现资源的 <code>CRUD</code> 呢？</p>
<h2 id="动词"><a href="#动词" class="headerlink" title="动词"></a>动词</h2><p>RESTful API 核心的设计思想就是通过 HTTP 协议原生的传输方法执行 <a href="http://baike.baidu.com/view/913128.htm" target="_blank" rel="external">CRUD</a></p>
<p>常用的 HTTP 动词如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">GET (SELECT)    : 从服务器获取资源。</div><div class="line">POST (CREATE)   : 在服务器新建一个资源</div><div class="line">PUT (UPDATE)    : 在服务器更新一个资源（修改后的完整资源）</div><div class="line">PATCH (UPDATE)  : 在服务器更新一个资源（修改的某一项属性）</div><div class="line">DELETE (DELETE) : 在服务器删除资源</div></pre></td></tr></table></figure>
<p>不常用：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">HEAD    ：获取资源的元数据,如数据的哈希值或最后的更新。</div><div class="line">OPTIONS ：获取客户端能对资源做什么操作的信息。</div></pre></td></tr></table></figure></p>
<p>例如：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">GET    /soaps     : 列出所有的肥皂品牌</div><div class="line">GET    /soaps/ID  :列出指定品牌的肥皂</div><div class="line">POST   /soaps     : 新建一个肥皂品牌</div><div class="line">PUT    /soaps/ID  : 更改某个指定的肥皂(包含所有的属性)</div><div class="line">PATCH  /soaps/ID  : 更改某个指定的肥皂(包含修改的属性)</div><div class="line">DELETE /soaps/ID  : 删除某个指定的肥皂</div></pre></td></tr></table></figure></p>
<p>那么如果我想取出某些特定的数据怎么做？</p>
<h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2><p>如果记录数量很多，我们需要对数据进行过滤。设计的 API 应该具有参数，可以返回过滤结果。可以设计冗余的参数。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- ?limit  =N           : 限制返回N个数据</div><div class="line">- ?page   =N           ：返回第N页数据</div><div class="line">- ?offset =N           ：从第N个数据开始</div><div class="line">- ?page   =N&amp;perpage=M ：返回第N页数据和每页显示M个</div><div class="line">- ?type   =something   ：类别</div><div class="line">- ?sortby =something   ：以何种属性排列</div><div class="line">- ?order  =asc/desc    ：排列顺序（升序/降序）</div></pre></td></tr></table></figure>
<h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p>用户向服务器请求数据后。服务器向用户返回<a href="http://baike.baidu.com/view/1311386.htm" target="_blank" rel="external"><code>状态码</code></a>和信息，常见的有：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">200 OK [GET]：服务器成功返回用户请求的数据，该操作是幂等的。</div><div class="line">201 CREATED [POST/PUT/PATCH]：用户新建或修改数据成功。</div><div class="line">202 Accepted [*]：表示一个请求已经进入后台排队（异步任务）</div><div class="line">204 NO CONTENT [DELETE]：用户删除数据成功。</div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">400 INVALID REQUEST [POST/PUT/PATCH]：用户发出的请求有错误，该操作是幂等的。</div><div class="line">401 Unauthorized[*]：表示用户没有权限（令牌、用户名、密码错误）。</div><div class="line">403 Forbidden   [*]：表示用户得到授权（与401错误相对），但是访问是被禁止的。</div><div class="line">404 NOT FOUND   [*]：用户发出的请求针对的是不存在的记录，该操作是幂等的。</div><div class="line">406 Not Acceptable [GET]：用户请求的格式不可得</div><div class="line">410 Gone [GET]：用户请求的资源被永久删除，且不会再得到的。</div><div class="line">422 Unprocesable entity [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。</div><div class="line">500 INTERNAL SERVER ERROR [*]：服务器发生错误，用户将无法判断发出的请求是否成功。</div></pre></td></tr></table></figure>
<h2 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h2><p>服务器向用户返回的结果应该符合规范<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">GET    /collection           ：返回资源对象的列表（数组）</div><div class="line">GET    /collection/resource  ：返回单个资源对象</div><div class="line">POST   /collection           ：返回新生成的资源对象</div><div class="line">PUT    /collection/resource  ：返回完整的资源对象</div><div class="line">PATCH  /collection/resource  ：返回完整的资源对象</div><div class="line">DELETE /collection/resource  ：返回一个空文档</div></pre></td></tr></table></figure></p>
<h2 id="超媒体API"><a href="#超媒体API" class="headerlink" title="超媒体API"></a>超媒体API</h2><p>在非超媒体RESTful API的情景中，URL端点是服务器与客户端契约的一部分。这些端点必须让客户端事先知道，并且修改它们也意味着客户端可能再也无法与服务器通信了。<br>超媒体API概念的运作跟人们的行为类似。通过请求API的根来获得一个URL的列表，这个列表里面的每一个URL都指向一个集合，并且提供了客户端可以理解的信息来描述每一个集合。是否为每一个资源提供ID并不重要（或者不是必须的），只要提供URL即可。</p>
<blockquote>
<p><a href="api.github.com">Github’s Hypermedia APIs</a></p>
</blockquote>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>我们应该为 API 设计一个文档以便开发者使用。</p>
<ul>
<li>API 文档尽量简洁明了</li>
<li>展示尽量完整，关键代码应该高亮显示</li>
<li>预期可能会发生的错误，解释在什么情况会会有错误。</li>
</ul>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><blockquote>
<p><a href="https://codeplanet.io/principles-good-restful-api-design/" target="_blank" rel="external">Principles of good RESTful API Design</a><br><a href="https://bourgeois.me/rest" target="_blank" rel="external">REST best practices</a><br><a href="http://www.cnblogs.com/moonz-wu/p/4211626.html" target="_blank" rel="external">好API的设计原则</a><br><a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="external">RESTful设计指南</a></p>
</blockquote>
<h4 id="版权"><a href="#版权" class="headerlink" title="版权"></a>版权</h4><p>author : <code>zhangrui</code><br>授权     ：自由转载-非商用</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;RESTful-学习手记（一）&quot;&gt;&lt;a href=&quot;#RESTful-学习手记（一）&quot; class=&quot;headerlink&quot; title=&quot;RESTful 学习手记（一）&quot;&gt;&lt;/a&gt;RESTful 学习手记（一）&lt;/h1&gt;&lt;h5 id=&quot;2016-10-17-周一
    
    </summary>
    
    
      <category term="RESTful" scheme="https://ukhack.github.io/tags/RESTful/"/>
    
      <category term="编程学习" scheme="https://ukhack.github.io/tags/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>第一次面试java研发实习</title>
    <link href="https://ukhack.github.io/2016-10-15-%E6%93%8E%E5%A4%A9%E7%A7%91%E6%8A%80.html"/>
    <id>https://ukhack.github.io/2016-10-15-擎天科技.html</id>
    <published>2016-10-14T16:00:00.000Z</published>
    <updated>2016-10-18T11:47:27.031Z</updated>
    
    <content type="html"><![CDATA[<h1 id="擎天科技校招面试"><a href="#擎天科技校招面试" class="headerlink" title="擎天科技校招面试"></a>擎天科技校招面试</h1><h5 id="2016-10-15-周六"><a href="#2016-10-15-周六" class="headerlink" title="2016-10-15 周六"></a>2016-10-15 周六</h5><hr>
<p>　　今天参与了擎天科技的校招面试。<br>　　<br>　　本校的学生我所看到的只有三位同学。面试研发岗位的人挺多，大部分是南信工，南工大的学生。我这样的专科学历已然不够用了。<br>　　<br>　　考官是挺随和的一个人，在面试开始时他让我大致介绍一下自己。我便说我来自哪儿，家在哪里吧啦吧啦的一堆乱七八糟的，现在想想真丢人，太紧张了 &gt;_&lt; 。<br>　　<br>　　考官提的问题其实还是蛮简单的，大致是按照简历上写的问。或许是我太紧张了，所以就想到一出是一出，我的天呐，真的是紧张到一点策略都没有。比如考官没想过问sqlserver我自己偏要作大死提学的不错，还说学的很深。任课的高老师曾经是公司的项目总监，还出了一本书，教的东西真是难的可以，仍记得当时那段时间写sql语句写的要吐，但是确实学了有一年过去了。结果考官问left join,transaction,cusor都只记得个大概了QAQ</p>
<p>　　面试官还是蛮重视经验的，在开始不久时就询问我从什么时候学习Java,我告诉他学习了一年，并且强调一直在用Java。接着问我实际开发一个项目从什么时候开始。说真的，面试开发项目经验真的是蛮重要的！　　</p>
<hr>
<p>总结：<br>　　面试前一定要组织好语言！项目经验可以弥补“智商”的不足，一定要多多积累，在面试时才有东西可谈。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;擎天科技校招面试&quot;&gt;&lt;a href=&quot;#擎天科技校招面试&quot; class=&quot;headerlink&quot; title=&quot;擎天科技校招面试&quot;&gt;&lt;/a&gt;擎天科技校招面试&lt;/h1&gt;&lt;h5 id=&quot;2016-10-15-周六&quot;&gt;&lt;a href=&quot;#2016-10-15-周六&quot; c
    
    </summary>
    
    
      <category term="面试" scheme="https://ukhack.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="实习" scheme="https://ukhack.github.io/tags/%E5%AE%9E%E4%B9%A0/"/>
    
      <category term="生活" scheme="https://ukhack.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>Hi Git!</title>
    <link href="https://ukhack.github.io/Hi-Git.html"/>
    <id>https://ukhack.github.io/Hi-Git.html</id>
    <published>2016-10-10T16:00:00.000Z</published>
    <updated>2016-10-18T11:46:47.510Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git-的起源"><a href="#Git-的起源" class="headerlink" title="Git 的起源"></a>Git 的起源</h2><blockquote>
<p>Git is a version control system that is used for software development and other version control tasks. As a distributed revision control system it is aimed at speed,data integrity, and support for distributed, non-linear workflows.</p>
<p>Git was created by Linus Torvalds in 2005 for development of the Linux kernel, with other kernel developers contributing to its initial development.</p>
<p>Like the Linux kernel, Git is free software distributed under the terms of the GNU General Public License version 2. </p>
<p><a href="https://en.wikipedia.org/wiki/Git" target="_blank" rel="external">Wikipedia</a></p>
</blockquote>
<p>　　Git 是一个版本控制软件用于软件开发和其他的版本控制任务。git作为分布式版本控制系统，它是针对速度，数据完整性，并且支持它分布式的，非线性的工作流程。<br>　　Git 最初由林纳斯·托瓦兹（Linus Torvalds）在2005年创作。最初目的是为更好地管理Linux内核开发而设计。像linux内核一样,Git是以GNU2协议免费发布的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Git-的起源&quot;&gt;&lt;a href=&quot;#Git-的起源&quot; class=&quot;headerlink&quot; title=&quot;Git 的起源&quot;&gt;&lt;/a&gt;Git 的起源&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Git is a version control system that 
    
    </summary>
    
    
      <category term="Git" scheme="https://ukhack.github.io/tags/Git/"/>
    
      <category term="Github" scheme="https://ukhack.github.io/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>搭建 Blog 笔记 (一)</title>
    <link href="https://ukhack.github.io/myfirst.html"/>
    <id>https://ukhack.github.io/myfirst.html</id>
    <published>2016-01-11T16:00:00.000Z</published>
    <updated>2016-10-17T08:29:55.034Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Git-的基本语法"><a href="#Git-的基本语法" class="headerlink" title="Git 的基本语法"></a>Git 的基本语法</h3><h5 id="新建本地-repository"><a href="#新建本地-repository" class="headerlink" title="新建本地 repository"></a>新建本地 repository</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#新建工作目录</div><div class="line">cd d:\workset</div><div class="line">mkdir gitone</div><div class="line">#初始化本地仓库</div><div class="line">git init</div></pre></td></tr></table></figure>
<a id="more"></a>
<h5 id="新建文件夹"><a href="#新建文件夹" class="headerlink" title="新建文件夹"></a>新建文件夹</h5><p>​    Github 的格式严格要求需要 _layouts,_posts 文件夹</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#_layouts 为页面的布局文件夹</div><div class="line">mkdir _layouts</div><div class="line"># _posts 为最新文章</div><div class="line">mkdir _posts</div><div class="line"></div><div class="line">#设置文件，主目录</div><div class="line">vim _config.yml</div><div class="line">#baseurl:/gitone</div><div class="line"></div><div class="line">#default.html 是默认格式</div><div class="line">vim _layout/default.html(内容下附)</div><div class="line">#文章内容格式必须为 yyyy-mm-dd-title(.html/.md)</div><div class="line">vim _posts/2016-01-12-myGithubPages.html(内容下附)</div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- default.html --&gt;</span></div><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line">　　<span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">　　<span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">　　　　<span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"content-type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span> /&gt;</span></div><div class="line">　　　　<span class="tag">&lt;<span class="name">title</span>&gt;</span>&#123;&#123; page.title &#125;&#125;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">　　<span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">　　<span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">　　　　&#123;&#123; content &#125;&#125;</div><div class="line">　　<span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line">　　<span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--myGithubPages.html--&gt;</span></div><div class="line">---</div><div class="line">layout: default</div><div class="line">title: 你好，世界</div><div class="line">---</div><div class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;page.title&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我的第一篇文章<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;page.date | date_to_string &#125;&#125; <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure>
<h5 id="提交至本地库"><a href="#提交至本地库" class="headerlink" title="提交至本地库"></a>提交至本地库</h5><p>​    Git中文件有三种状态：Untracked files、Changes to be committed、Changes not staged for commit</p>
<p>通过 git status 查看。只有 changes to be committed 状态才能被提交</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#将所有文件加入待提交列表</span></div><div class="line">git add .</div><div class="line"><span class="comment">#提交至本地 repository</span></div><div class="line">git commit -m <span class="string">'I create a new page!'</span></div></pre></td></tr></table></figure>
<h5 id="提交至远程库"><a href="#提交至远程库" class="headerlink" title="提交至远程库"></a>提交至远程库</h5><p>​    在此之前确保 Github 中的 repository 名为 username(ukhack).github.io</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push origin master</div></pre></td></tr></table></figure>
<p>打开 ukhack.github.io 查看情况</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Git-的基本语法&quot;&gt;&lt;a href=&quot;#Git-的基本语法&quot; class=&quot;headerlink&quot; title=&quot;Git 的基本语法&quot;&gt;&lt;/a&gt;Git 的基本语法&lt;/h3&gt;&lt;h5 id=&quot;新建本地-repository&quot;&gt;&lt;a href=&quot;#新建本地-repository&quot; class=&quot;headerlink&quot; title=&quot;新建本地 repository&quot;&gt;&lt;/a&gt;新建本地 repository&lt;/h5&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;#新建工作目录&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;cd d:\workset&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;mkdir gitone&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;#初始化本地仓库&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;git init&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Github" scheme="https://ukhack.github.io/tags/Github/"/>
    
      <category term="Blog" scheme="https://ukhack.github.io/tags/Blog/"/>
    
  </entry>
  
</feed>
