{"meta":{"title":"Road of web","subtitle":"极客笔记","description":"一只web鼠的个人笔记","author":"Zhang rui","url":"https://ukhack.github.io"},"pages":[{"title":"","date":"2016-10-15T12:08:34.035Z","updated":"2016-10-15T12:08:34.035Z","comments":false,"path":"tags/index.html","permalink":"https://ukhack.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JavaScript OOP的理解（一）","slug":"JavaScript OOP的理解（一）","date":"2016-12-15T16:00:00.000Z","updated":"2017-07-24T03:55:33.528Z","comments":true,"path":"JavaScript OOP的理解（一）.html","link":"","permalink":"https://ukhack.github.io/JavaScript OOP的理解（一）.html","excerpt":"","text":"JavaScript OOP的理解（一）2016-12-16 星期六这篇文章旨在记录我个人在日常编码中对 JavaScript 面向对象编程的一些理解，由于阅历原因，可能有些片面和不足，欢迎指出。 OOPOOP ：面向对象编程。如果接触过 JAVA 或者 C++ 那么应该很清楚这个概念，OOP有三大特征即：封装、继承和多态。 封装封装是指将数据与操作包装成为一个单独的实体，数据尽可能的被隐藏在内部，而只保留一些对外的接口使之与外部联系。 使用好封装可以带来以下几点好处： 好的封装可以减少模块间的耦合，提高内聚性 可以隐藏不想被外部知道的细节，提升安全性 可以更精准的控制内部的成员变量 继承OOP 的主要功能之一就是继承。我们知道，在实际项目中，代码复用是非常重要的。我们不必要为了修改一点点不同的功能而又去重新写一模一样的代码。 继承是一种能力，我们可以从现有的类中派生出一个新类。被基础的类叫做“基类”或者“父类”，派生出的类叫做“派生类”或者“子类”。派生类可以从基类继承方法和变量，同时可以加入新的方法，这将不会影响父类的现有代码，同时减少了很多的重复代码。 在 JAVA 项目中我们可以看到很多这样的实例，如 java.lang 包中，很多的类都被继承。或者是当前很热的 ORM 框架 Mybatis 的 resultMap 也是支持继承的。 多态在现实中，多态的例子其实很多：比如说按下F5按键，在浏览器页面和桌面是刷新，在word中是查找替换，而在PPT中又是播放。同样一个按钮，不同的场景功能就不同。 那么多态的含义就好理解了：对于不同类的对象，允许他们对同一个消息响应。就是说同一个消息可以根据不同的对象来采用不同的方式。 实现多态必须满足： 完成继承 完成重载 父类引用指向子类 以上是面向对象的三个基本特征，如果能够符合，那么就是面向对象。那么我们来看看 JS 如何做到面向对象。 JavaScript OOP上面讲了 OOP 的基本的特征，但是有一个问题我们大家心里面都是有数的。那就是：JavaScript 压根没有 class（ES2015以及更早），这就导致 JS 的编写很尴尬。在我的工作过程中，我实际编写了很多的 JS 模块，纵观这些代码也是我进步的一个过程。同时我也在维护前辈们留下的代码。最为头疼的就是有时候打开一个 JS 文件，四千多行，没有注释，满屏幕都是 function xx(){…} ，项目赶得紧又没有多余时间去重写这些文件，想死的心都有了。所以我宁可去维护后端也不想去维护前端，我也很无奈~究其原因就是项目组来来去去的人员变动的大，水平也参差不齐。如果他们能掌握 OOP ，那么写出来的代码也更易于阅读，对我们这些晚辈也更友好。回到正题。在传统的面向对象语言中，我们可以说，我为 Car 类创建了一个对象叫 Audi 。而由于JS缺少class特性，并且JS完全是基于对象的，依靠的是一套原型系统（prototype）。在 JS 中，我们可以说，我把 Car 对象扩展成了 Audi新对象。 示例 概念 奥迪a6是小轿车（小轿车是对象） 对象 奥迪a6 价格400K，排量1.8T 属性 奥迪a6 起步，加油，刹车，换挡 方法 奥迪是小轿车类的一个实例 传统的OOP 奥迪是小轿车对象扩展出来的新对象 基于原型的OOP 奥迪 a6 中包含了坐垫，内饰等数据，以及更换坐垫，更换内饰等方法 封装 奥迪的起步，刹车，换挡都是扩展自小轿车对象的新对象 继承 我们可以调用奥迪的驾驶，宝马的驾驶，奔驰的驾驶，他们风格不同导致结果不同 重载，多态","categories":[],"tags":[{"name":"实习","slug":"实习","permalink":"https://ukhack.github.io/tags/实习/"},{"name":"javascript","slug":"javascript","permalink":"https://ukhack.github.io/tags/javascript/"},{"name":"OOP","slug":"OOP","permalink":"https://ukhack.github.io/tags/OOP/"}],"keywords":[]},{"title":"mysql远程可访问，本地非root无法访问解决方案","slug":"mysql登录问题的一个坑","date":"2016-12-12T16:00:00.000Z","updated":"2017-09-07T10:37:35.940Z","comments":true,"path":"mysql登录问题的一个坑.html","link":"","permalink":"https://ukhack.github.io/mysql登录问题的一个坑.html","excerpt":"","text":"mysql远程可访问，本地非root无法访问解决方案2016-12-12 星期二最近在使用mysql5.5中遇到了一个坑。 发现问题通常，在mysql安装完毕后我们并不会使用自带的root用户，以规避爆破的风险。1mysql&gt;grant all PRIVILEGES on *.* to zr@&apos;%&apos; identified by &apos;z********6&apos;; grant all命令可以为我新建一个用户zr(名字缩写)，并赋予了其root权限。zr用户的主机是%，意味着可以远程登录。关掉puty,我在本地的mysql输入：12$ mysql -h 67.21.*.183 -u zr -p&apos;z********6&apos;;mysql&gt; 可以成功登录。但是打开puty,登录mysql问题来了，给我报了个错1Access denied for user &apos;zr&apos;@&apos;localhost&apos; (using password: YES) 我试着使用root登录:12$ mysql -u root -p&apos;**********&apos;;mysql&gt; 这真令人尴尬，root可以本地登录但是我新建的zr不可以登录，但是zr又可以远程登录。 解决问题乖乖爬墙，发现一个方案是修改host1localhost 127.0.0.1 然而无效。基本可以排除并不是解析的问题。登录root查用户：1234567$ mysql -u root -p&apos;**********&apos;;mysql&gt;select host,user,password from mysql.user where user=&apos;zr&apos;+---------+--------+-------------------------------------------+| host | user | password |+---------+--------+-------------------------------------------+| % | zr | *2CC0511FAC200EDC90EEF9CFC206B07E7BD90F97 |+---------+--------+-------------------------------------------+ 排除用户创建的问题。那么问题到底出在哪？再次查询用户1234567891011$ mysql -u root -p&apos;**********&apos;;mysql&gt;select host,user,password from mysql.user where user=&apos;zr&apos;+----------+-------+-------------------------------------------+| host | user | password |+----------+-------+-------------------------------------------+| localhost| root | *2CC0511FAC200EDC90EEF9CFC206B07E7BD90F97 || 127.0.0.1| root | *2CC0511FAC200EDC90EEF9CFC206B07E7BD90F97 || ::1 | root | *2CC0511FAC200EDC90EEF9CFC206B07E7BD90F97 || localhost| | || % | zr | *2CC0511FAC200EDC90EEF9CFC206B07E7BD90F97 |+----------+-------+-------------------------------------------+ 看到这里我想你们应该知道问题在哪了，没错。问题出在第三行，原理后面说。1234567891011$ mysql -u root -p&apos;**********&apos;;mysql&gt;select host,user,password from mysql.user where user=&apos;zr&apos;+----------+-------+-------------------------------------------+| host | user | password |+----------+-------+-------------------------------------------+| localhost| root | *2CC0511FAC200EDC90EEF9CFC206B07E7BD90F97 || 127.0.0.1| root | *2CC0511FAC200EDC90EEF9CFC206B07E7BD90F97 || ::1 | root | *2CC0511FAC200EDC90EEF9CFC206B07E7BD90F97 || localhost| | || % | zr | *2CC0511FAC200EDC90EEF9CFC206B07E7BD90F97 |+----------+-------+-------------------------------------------+ 进行修复：123mysql&gt;delete from user where user=&apos;&apos;Query OK, 2 rows affected (0.00 sec)mysql&gt;flush privileges; 重新登录成功 ###原理其实mysql权限认证的修改就是对mysql.user这张表的增删改查。当我们登录时，mysql会去user表遍历一遍，以找到的第一个匹配项匹配，不再向下匹配。找不到匹配的就会阻断用户的请求。而我们看到所有用户中的是有匿名用户存在的。之所以root可以登录成功是因为localhost+root排在第一个匹配位，理所当然的可以登录成功。而在zr前面是有一个user=’’的匿名用户，它的匹配优先级高于zr，这导致我无法用zr登录，哪怕登录了也是匿名用户。最终方法就是删掉匿名用户，原理是不是很简单。 版权author : zhangrui授权 ：自由转载-非商用","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://ukhack.github.io/tags/mysql/"}],"keywords":[]},{"title":"通过forever使nodejs运行在后台","slug":"利用forever使nodejs可以在后台运行","date":"2016-12-11T16:00:00.000Z","updated":"2017-09-07T09:24:12.573Z","comments":true,"path":"利用forever使nodejs可以在后台运行.html","link":"","permalink":"https://ukhack.github.io/利用forever使nodejs可以在后台运行.html","excerpt":"","text":"forever的使用2016-12-12 星期一我们常用node app.js这条命令来运行node应用，但是如果退出terminal就会导致node进程退出，这是我们不想看到的，那么如果想要nodejs在后台运行，并且异常退出后可以自动启动如何做到？ 最简单的办法： 1$ nohup node app.js &amp; 但是，forever能做更多的事情，比如分别记录输出和错误日志，比如可以在js中作为api使用。 12345$ npm install forever -g #安装$ forever start app.js #启动$ forever stop app.js #关闭$ forever -w app.js #监听app.js自动重启$ forever start -l forever.log -o out.log -e err.log app.js #输出日志和错误 版权author : zhangrui授权 ：自由转载-非商用","categories":[],"tags":[{"name":"实习","slug":"实习","permalink":"https://ukhack.github.io/tags/实习/"},{"name":"javascript","slug":"javascript","permalink":"https://ukhack.github.io/tags/javascript/"},{"name":"OOP","slug":"OOP","permalink":"https://ukhack.github.io/tags/OOP/"}],"keywords":[]},{"title":"项目中jquery遇到问题的反思和总结","slug":"项目使用Jquery遇到问题的反思与总结","date":"2016-12-05T16:00:00.000Z","updated":"2017-07-24T02:11:01.930Z","comments":true,"path":"项目使用Jquery遇到问题的反思与总结.html","link":"","permalink":"https://ukhack.github.io/项目使用Jquery遇到问题的反思与总结.html","excerpt":"","text":"Jquery遇到问题的反思和总结2016-12-6 星期二这篇文章不是介绍如何使用jquery，而是旨在总结我在擎天实习期间，在项目上使用 jquery 时遇到的问题的一个反思和总结。由于项目必须兼容IE8，所以下面的内容都是基于 Jquery1.8 以及以下的版本。 问题1：绑定事件我们知道，Jquery 中常用的给指定元素绑定监听事件方法之一是 bind 方法。例如: 1$('#p1').bind('click',function()&#123;console.log('hello p1')&#125;); 显而易见的，在控制台会打印出 “hello p1” 这段字符。但是 Jquery 一大功能就是对 ajax 取到的数据进行解析，然后修改 DOM 节点。很多的新的节点被动态的附加到 DOM 树上，这时候我们写好的 bind 方法对这些节点将会失效。查文档得知 Jquery 还有一个方法 ： 1.live(type, [data], fn) 这个方法对 append,after 等等都有效。为什么这个方法对后来附加的方法有效？这个原理其实可以追溯到我们刚接触到 js 时会遇到的一个问题，那就是：事件冒泡。也就是说，我们其实是将方法放在了document 这个节点，在触发点击事件时进行冒泡，最后对对象进行匹配。这又称作“事件委托”。激动的改成了 live() 以后，没想到程序居然跑不起来了，这是为什么？在这个文件中，我为了优化 jq 的效率用到了很多类似：1234var ele=$('#dataForm .reportData');ele.find(' .dataTitle').bind....ele.find(' .dataDetail').bind...... 充分利用 jq 的缓存可以优化我们的运行速度。但是恰巧，在 api 文档中我发现了如下的一个问题： .live() 方法居然是不支持 find 遍历的。其实 .live() 在 jq1.7 这个版本已经不再推荐使用了，取而代之的是 on 方法，live 方法确实也存在着很多问题。换成了 .on() 以后，问题得到了解决。 问题2：待补充版权author : zhangrui授权 ：自由转载-非商用","categories":[],"tags":[{"name":"实习","slug":"实习","permalink":"https://ukhack.github.io/tags/实习/"},{"name":"生活","slug":"生活","permalink":"https://ukhack.github.io/tags/生活/"},{"name":"javascript","slug":"javascript","permalink":"https://ukhack.github.io/tags/javascript/"}],"keywords":[]},{"title":"Vue.js 手札（一）","slug":"Vue-1","date":"2016-11-10T16:00:00.000Z","updated":"2016-11-16T04:05:24.752Z","comments":true,"path":"Vue-1.html","link":"","permalink":"https://ukhack.github.io/Vue-1.html","excerpt":"","text":"","categories":[],"tags":[{"name":"编程学习","slug":"编程学习","permalink":"https://ukhack.github.io/tags/编程学习/"},{"name":"Vue","slug":"Vue","permalink":"https://ukhack.github.io/tags/Vue/"}],"keywords":[]},{"title":"REST成熟度的思考","slug":"REST成熟度的思考","date":"2016-10-17T16:00:00.000Z","updated":"2017-07-11T10:16:38.726Z","comments":true,"path":"REST成熟度的思考.html","link":"","permalink":"https://ukhack.github.io/REST成熟度的思考.html","excerpt":"","text":"REST成熟度2016-10-18 周二上篇文章我分析了 REST 接口的命名规范，大概是从十个方面分析了这个技术。这篇文章探讨在 REST 发展过程中形成的几个成熟度模型。 Recently I’ve been reading drafts of Rest In Practice: a book that a couple of my colleagues have been working on. Their aim is to explain how to use Restful web services to handle many of the integration problems that enterprises face. At the heart of the book is the notion that the web is an existence proof of a massively scalable distributed system that works really well, and we can take ideas from that to build integrated systems more easily. Martin Fowler 最近，我拜读了《 REST 实战》这本书的草案。我的很多同事参与了此书的编写。他们旨在研究如何在 web 服务中使用 RESTful 来解决很多企业面临的集成问题。这本书的核心观点就是： web 的存在证明了大规模可扩展的分布式系统，我们可以借鉴书里面的思想来让我们的更简单的搭建集成系统。（原谅我捉鸡的翻译） 首先先祭出这张图片： 从下往上看是四级。 Level 0为什么叫 level 0 呢？那是因为这个级别在当前阶段可以说是不属于 REST 范畴的，只是用以说明 REST 发展的历史。 在这个级别我们使用 XML (也有 JSON 、YAML 或者其他)，只有POX被传输，基本就是 RPC 的风格。如 SAOP也是相似的，只是格式不同而已。所以说，Level 0 是不应该属于REST的。 Level 1在该成熟度模型中，我们可以看到。REST 入门级别是资源级别：就是将所有的请求抽象为对资源的操作。例如下面的一个例子 这个接口是微信公众号的数据分析接口，对用户数据进行了资源化。我们不难看出，虽然依然是 POX 但是每一个资源都拥有其独立的 URL 地址。这就是 Level 1 的要求，每一个资源对应独立的 URL 地址。 我们可以看到，微信公众号这两个接口的命名其实是不满足我上一篇文章所说的， url 应该只包含名词，而不是动词。所以我们接下来继续分析 Level 2 。 Level 2level 2 级别引入了 http 动词的概念，即：url中应该存在的是资源的名词形式，而不应该存在形如 get 、 set 这样的动词，我们应该在请求中用 http 动词替代 url 中的动词。 常用的 HTTP 动词如下： 12345GET (SELECT) : 从服务器获取资源。POST (CREATE) : 在服务器新建一个资源PUT (UPDATE) : 在服务器更新一个资源（修改后的完整资源）PATCH (UPDATE) : 在服务器更新一个资源（修改的某一项属性）DELETE (DELETE) : 在服务器删除资源 如： 这是微信公众平台的长链接获取短链接的接口，这个接口就用了名词的 shorturl 和 http 动词 POST 让开发者一目了然。而这里为什么使用 POST 而不是 GET 呢？ 可以这么看，获取短链接其实也是创建了一个短链接的资源，这个资源原本是不存在的。不必要过于墨守成规。我翻阅了一遍微信公众平台的 api 遗憾的是，可能是历史的原因，微信公众平台的很多接口其实只能算是一级成熟度的 REST。 Level 3我们再次祭出这张图片： 从字面上理解 level 3 是超媒体控制。这个像是机翻的中文名看起来很是令人困惑。什么叫做超媒体控制？ 别急，让我来举一个简单的例子： 1curl -X curl https://*.wilddogio.com/books.json 响应：12345678910111213141516&#123; \"book1\":&#123; \"name\": \"书1\", \"next\": \"*.wilddogio.com/books/book2.json\", \"self\": \"*.wilddogio.com/books/book1.json\" &#125;, \"book2\":&#123; \"name\": \"书2\", \"next\": \"*.wilddogio.com/books/book3.json\", \"self\": \"*.wilddogio.com/books/book2.json\" &#125;, \"book3\":&#123; \"name\": \"书3\", \"self\": \"*.wilddogio.com/books/book3.json\" &#125;&#125; 我们看其中一个：12345\"book2\":&#123; \"name\": \"书2\", \"next\": \"walletdemo.wilddogio.com/books/book3.json\", \"self\": \"walletdemo.wilddogio.com/books/book2.json\" &#125; Level 3 对REST请求已经没有要求，而要求响应做一定的更改。它要求响应体具有一定的自描述性：即开发者阅读了这个响应以后就算不借助api文档也能明白下一步该做什么。 book2资源的响应描述了自己的url地址，以及它的下一个地址。所有的资源通过url串联在一起。这就是 Level 3似乎并没有想像中的那么难吧？不过目前 Level 3 正在制定中，并没有一个成型的规则去约束，所以我们只要满足自描述这个要求即可，而如何描述，描述成什么样子这就需要等待新的规则制定出来。 后记REST 就分析到这里啦，希望看到这篇文章的有心人可以将这篇理论带到实战中去。我是 zhang rui ，乐于分享不一样的知识。 引用 Richardson成熟度模型好API的设计原则RESTful 学习手记（一） 版权author : zhangrui授权 ：自由转载-非商用","categories":[],"tags":[{"name":"RESTful","slug":"RESTful","permalink":"https://ukhack.github.io/tags/RESTful/"},{"name":"编程学习","slug":"编程学习","permalink":"https://ukhack.github.io/tags/编程学习/"}],"keywords":[]},{"title":"RESTful 手札（一）","slug":"2016-10-17-RESTful-1","date":"2016-10-16T16:00:00.000Z","updated":"2016-10-18T11:53:15.428Z","comments":true,"path":"2016-10-17-RESTful-1.html","link":"","permalink":"https://ukhack.github.io/2016-10-17-RESTful-1.html","excerpt":"","text":"RESTful 学习手记（一）2016-10-17 周一在如今前后端分离的大潮流下，诞生了各种 API 框架。其中最火发展最成熟的 RESTful API 设计思想也催生了很多新潮的 API 框架。 REST APIs are a very common topic nowaday; they are part of almost every web application. A simple, consistent and pragmatic interface is a mandatory thing; it will be much easier for others to use your API. Even if these practices may look common to your eye, I often see people that don’t really respect them. That’s why I decided to write a post about it. bourgeois 协议HTTP/HTTPS 域名提倡专用二级域名如下： 1https://api.domains.com 如果项目较小，也可以考虑如下方式 1https://www.domains.com/api/something 这两种方式都是合理的，可在实际项目中酌情选择 API 版本api 版本号应该显式的约定在在 url 中 12https://api.domains.com/v1https://domains.com/api/v1/ Github 的 api 隐藏在接收到的 http head 信息中。 使用版本号可以让你在更新 api 时避免破坏旧版本的 api 路径Endpoint 应该是复数名词而不是动词。在 RESTful 中，一个网址即对应一个资源。 形如： 123https://api.domains.com/v1/soapshttps://api.domains.com/v1/gayshttps://api.domains.com/v1/programmers 是合理的。 而形如： 123https://api.domains.com/v1/pickSoapshttps://api.domains.com/v1/becomeGayhttps://api.domains.com/v1/getProgrammers 这种传统的 get\\set 或者包含其他动词的 Endpoint 应该避免。 那么我们该怎么实现资源的 CRUD 呢？ 动词RESTful API 核心的设计思想就是通过 HTTP 协议原生的传输方法执行 CRUD 常用的 HTTP 动词如下： 12345GET (SELECT) : 从服务器获取资源。POST (CREATE) : 在服务器新建一个资源PUT (UPDATE) : 在服务器更新一个资源（修改后的完整资源）PATCH (UPDATE) : 在服务器更新一个资源（修改的某一项属性）DELETE (DELETE) : 在服务器删除资源 不常用：12HEAD ：获取资源的元数据,如数据的哈希值或最后的更新。OPTIONS ：获取客户端能对资源做什么操作的信息。 例如：123456GET /soaps : 列出所有的肥皂品牌GET /soaps/ID :列出指定品牌的肥皂POST /soaps : 新建一个肥皂品牌PUT /soaps/ID : 更改某个指定的肥皂(包含所有的属性)PATCH /soaps/ID : 更改某个指定的肥皂(包含修改的属性)DELETE /soaps/ID : 删除某个指定的肥皂 那么如果我想取出某些特定的数据怎么做？ 过滤如果记录数量很多，我们需要对数据进行过滤。设计的 API 应该具有参数，可以返回过滤结果。可以设计冗余的参数。 1234567- ?limit =N : 限制返回N个数据- ?page =N ：返回第N页数据- ?offset =N ：从第N个数据开始- ?page =N&amp;perpage=M ：返回第N页数据和每页显示M个- ?type =something ：类别- ?sortby =something ：以何种属性排列- ?order =asc/desc ：排列顺序（升序/降序） 状态码用户向服务器请求数据后。服务器向用户返回状态码和信息，常见的有： 1234200 OK [GET]：服务器成功返回用户请求的数据，该操作是幂等的。201 CREATED [POST/PUT/PATCH]：用户新建或修改数据成功。202 Accepted [*]：表示一个请求已经进入后台排队（异步任务）204 NO CONTENT [DELETE]：用户删除数据成功。 12345678400 INVALID REQUEST [POST/PUT/PATCH]：用户发出的请求有错误，该操作是幂等的。401 Unauthorized[*]：表示用户没有权限（令牌、用户名、密码错误）。403 Forbidden [*]：表示用户得到授权（与401错误相对），但是访问是被禁止的。404 NOT FOUND [*]：用户发出的请求针对的是不存在的记录，该操作是幂等的。406 Not Acceptable [GET]：用户请求的格式不可得410 Gone [GET]：用户请求的资源被永久删除，且不会再得到的。422 Unprocesable entity [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。500 INTERNAL SERVER ERROR [*]：服务器发生错误，用户将无法判断发出的请求是否成功。 返回结果服务器向用户返回的结果应该符合规范123456GET /collection ：返回资源对象的列表（数组）GET /collection/resource ：返回单个资源对象POST /collection ：返回新生成的资源对象PUT /collection/resource ：返回完整的资源对象PATCH /collection/resource ：返回完整的资源对象DELETE /collection/resource ：返回一个空文档 超媒体API在非超媒体RESTful API的情景中，URL端点是服务器与客户端契约的一部分。这些端点必须让客户端事先知道，并且修改它们也意味着客户端可能再也无法与服务器通信了。超媒体API概念的运作跟人们的行为类似。通过请求API的根来获得一个URL的列表，这个列表里面的每一个URL都指向一个集合，并且提供了客户端可以理解的信息来描述每一个集合。是否为每一个资源提供ID并不重要（或者不是必须的），只要提供URL即可。 Github’s Hypermedia APIs 文档我们应该为 API 设计一个文档以便开发者使用。 API 文档尽量简洁明了 展示尽量完整，关键代码应该高亮显示 预期可能会发生的错误，解释在什么情况会会有错误。 引用 Principles of good RESTful API DesignREST best practices好API的设计原则RESTful设计指南 版权author : zhangrui授权 ：自由转载-非商用","categories":[],"tags":[{"name":"RESTful","slug":"RESTful","permalink":"https://ukhack.github.io/tags/RESTful/"},{"name":"编程学习","slug":"编程学习","permalink":"https://ukhack.github.io/tags/编程学习/"}],"keywords":[]},{"title":"第一次面试java研发实习","slug":"2016-10-15-擎天科技","date":"2016-10-14T16:00:00.000Z","updated":"2016-10-18T11:47:27.031Z","comments":true,"path":"2016-10-15-擎天科技.html","link":"","permalink":"https://ukhack.github.io/2016-10-15-擎天科技.html","excerpt":"","text":"擎天科技校招面试2016-10-15 周六 今天参与了擎天科技的校招面试。 本校的学生我所看到的只有三位同学。面试研发岗位的人挺多，大部分是南信工，南工大的学生。我这样的专科学历已然不够用了。 考官是挺随和的一个人，在面试开始时他让我大致介绍一下自己。我便说我来自哪儿，家在哪里吧啦吧啦的一堆乱七八糟的，现在想想真丢人，太紧张了 &gt;_&lt; 。 考官提的问题其实还是蛮简单的，大致是按照简历上写的问。或许是我太紧张了，所以就想到一出是一出，我的天呐，真的是紧张到一点策略都没有。比如考官没想过问sqlserver我自己偏要作大死提学的不错，还说学的很深。任课的高老师曾经是公司的项目总监，还出了一本书，教的东西真是难的可以，仍记得当时那段时间写sql语句写的要吐，但是确实学了有一年过去了。结果考官问left join,transaction,cusor都只记得个大概了QAQ 面试官还是蛮重视经验的，在开始不久时就询问我从什么时候学习Java,我告诉他学习了一年，并且强调一直在用Java。接着问我实际开发一个项目从什么时候开始。说真的，面试开发项目经验真的是蛮重要的！ 总结： 面试前一定要组织好语言！项目经验可以弥补“智商”的不足，一定要多多积累，在面试时才有东西可谈。","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://ukhack.github.io/tags/面试/"},{"name":"实习","slug":"实习","permalink":"https://ukhack.github.io/tags/实习/"},{"name":"生活","slug":"生活","permalink":"https://ukhack.github.io/tags/生活/"}],"keywords":[]},{"title":"Hi Git!","slug":"Hi-Git","date":"2016-10-10T16:00:00.000Z","updated":"2016-10-18T11:46:47.510Z","comments":true,"path":"Hi-Git.html","link":"","permalink":"https://ukhack.github.io/Hi-Git.html","excerpt":"","text":"Git 的起源 Git is a version control system that is used for software development and other version control tasks. As a distributed revision control system it is aimed at speed,data integrity, and support for distributed, non-linear workflows. Git was created by Linus Torvalds in 2005 for development of the Linux kernel, with other kernel developers contributing to its initial development. Like the Linux kernel, Git is free software distributed under the terms of the GNU General Public License version 2. Wikipedia Git 是一个版本控制软件用于软件开发和其他的版本控制任务。git作为分布式版本控制系统，它是针对速度，数据完整性，并且支持它分布式的，非线性的工作流程。 Git 最初由林纳斯·托瓦兹（Linus Torvalds）在2005年创作。最初目的是为更好地管理Linux内核开发而设计。像linux内核一样,Git是以GNU2协议免费发布的。","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"https://ukhack.github.io/tags/Git/"},{"name":"Github","slug":"Github","permalink":"https://ukhack.github.io/tags/Github/"}],"keywords":[]},{"title":"搭建 Blog 笔记 (一)","slug":"myfirst","date":"2016-01-11T16:00:00.000Z","updated":"2016-10-17T08:29:55.034Z","comments":true,"path":"myfirst.html","link":"","permalink":"https://ukhack.github.io/myfirst.html","excerpt":"Git 的基本语法新建本地 repository12345#新建工作目录cd d:\\worksetmkdir gitone#初始化本地仓库git init","text":"Git 的基本语法新建本地 repository12345#新建工作目录cd d:\\worksetmkdir gitone#初始化本地仓库git init 新建文件夹​ Github 的格式严格要求需要 _layouts,_posts 文件夹 12345678910111213#_layouts 为页面的布局文件夹mkdir _layouts# _posts 为最新文章mkdir _posts#设置文件，主目录vim _config.yml#baseurl:/gitone#default.html 是默认格式vim _layout/default.html(内容下附)#文章内容格式必须为 yyyy-mm-dd-title(.html/.md)vim _posts/2016-01-12-myGithubPages.html(内容下附) 1234567891011&lt;!-- default.html --&gt;&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\" /&gt; &lt;title&gt;&#123;&#123; page.title &#125;&#125;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &#123;&#123; content &#125;&#125; &lt;/body&gt; &lt;/html&gt; 12345678&lt;!--myGithubPages.html--&gt;---layout: defaulttitle: 你好，世界---&lt;h2&gt;&#123;&#123;page.title&#125;&#125;&lt;/h2&gt;&lt;p&gt;我的第一篇文章&lt;/p&gt;&lt;p&gt;&#123;&#123;page.date | date_to_string &#125;&#125; &lt;/p&gt; 提交至本地库​ Git中文件有三种状态：Untracked files、Changes to be committed、Changes not staged for commit 通过 git status 查看。只有 changes to be committed 状态才能被提交 1234#将所有文件加入待提交列表git add .#提交至本地 repositorygit commit -m 'I create a new page!' 提交至远程库​ 在此之前确保 Github 中的 repository 名为 username(ukhack).github.io 1git push origin master 打开 ukhack.github.io 查看情况","categories":[],"tags":[{"name":"Github","slug":"Github","permalink":"https://ukhack.github.io/tags/Github/"},{"name":"Blog","slug":"Blog","permalink":"https://ukhack.github.io/tags/Blog/"}],"keywords":[]}]}